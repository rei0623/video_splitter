<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>多機能動画分割ツール v2.2 (ショートカット&スクロール対応)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
    body { font-family: sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: #f0f2f5; color: #333; display: flex; flex-direction: column; align-items: center; }
    .container { max-width: 800px; width: 100%; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
    h1 { text-align: center; color: #1a2b4d; margin-bottom: 30px; font-size: 2em; }

    /* Tabs for modes */
    .tabs { display: flex; margin-bottom: 20px; border-bottom: 1px solid #ddd; }
    .tab-button { padding: 10px 15px; cursor: pointer; background-color: #f9f9f9; border: 1px solid #ddd; border-bottom: none; margin-right: 5px; border-radius: 5px 5px 0 0; font-weight: bold; }
    .tab-button.active { background-color: #fff; border-bottom: 1px solid #fff; position: relative; top: 1px; color: #007bff; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* General UI Elements */
    label { display: block; margin-bottom: 8px; font-weight: bold; color: #555; }
    input[type="file"], input[type="number"], input[type="text"], select, button { width: 100%; padding: 12px; margin-bottom: 15px; border-radius: 6px; border: 1px solid #ccc; box-sizing: border-box; font-size: 16px; transition: border-color 0.2s ease; }
    input[type="file"] { padding: 8px; }
    input:focus, select:focus, button:focus { border-color: #007bff; outline: none; box-shadow: 0 0 0 2px rgba(0,123,255,.25); }
    input.invalid-input { border-color: red; background-color: #ffebeb; }
    button { background-color: #007bff; color: white; border: none; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; font-weight: bold; }
    button:hover:not(:disabled) { background-color: #0056b3; }
    button:active:not(:disabled) { transform: scale(0.98); }
    button:disabled { background-color: #adb5bd; cursor: not-allowed; }

    .input-group { display: flex; gap: 10px; align-items: center; margin-bottom: 15px; }
    .input-group label { margin-bottom: 0; flex-shrink: 0; }
    .input-group input[type="text"], .input-group input[type="number"] { flex-grow: 1; margin-bottom: 0; }
    .input-group input[type="number"] { min-width: 80px; text-align: right; }

    .options-section, .mode-section { margin-bottom: 25px; padding: 20px; border: 1px solid #e0e0e0; border-radius: 6px; background-color: #fdfdfd; }
    .options-section h3, .mode-section h3 { margin-top: 0; font-size: 1.2em; color: #333; border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 15px; }

    /* Video and Timeline */
    #sourceVideoContainer { position: relative; margin-bottom: 5px; scroll-margin-top: 20px; /* For scrollIntoView offset */ }
    #sourceVideo { width: 100%; max-height: 450px; background-color: #000; border-radius: 6px; display: none; }
    #customControls { display:none; padding: 5px; background: #333; text-align:center; border-radius: 0 0 6px 6px;}
    #customControls button { width:auto; padding: 8px 12px; font-size:0.9em; margin:0 5px; }
    #currentTimeDisplay, #durationDisplay { color:white; margin: 0 10px; font-size:0.9em; }

    #timelineContainer { width: 100%; height: 40px; background-color: #e9ecef; margin-bottom: 20px; position: relative; border-radius: 4px; overflow: hidden; cursor: pointer; }
    #timelineProgress { width: 0%; height: 100%; background-color: #007bff; opacity: 0.7; pointer-events: none; }
    .timeline-marker { position: absolute; top: 0; width: 3px; height: 100%; background-color: red; z-index: 10; cursor:ew-resize; }
    .timeline-marker.editing-start { background-color: orange; box-shadow: 0 0 5px orange; }
    .timeline-marker.editing-end { background-color: darkorange; box-shadow: 0 0 5px darkorange; }
    .segment-range-on-timeline { position: absolute; top: 0; height: 100%; background-color: rgba(0, 123, 255, 0.3); z-index: 5; pointer-events: none; transition: background-color 0.2s ease, box-shadow 0.2s ease; }
    .segment-range-on-timeline.hovered { background-color: rgba(0, 123, 255, 0.5); box-shadow: 0 0 8px rgba(0,123,255,0.5); }
    .segment-range-on-timeline.editing { background-color: rgba(255, 165, 0, 0.4); border: 1px dashed orange; }
    #timelineTooltip { position: absolute; background-color: rgba(0,0,0,0.75); color: white; padding: 5px 8px; border-radius: 4px; font-size: 0.85em; display: none; z-index: 100; pointer-events: none; white-space: nowrap; }


    /* Segment List */
    #segmentsListContainer h3 { font-size: 1.2em; margin-bottom: 10px; }
    .segment-item { background-color: #f9f9f9; padding: 12px; border-radius: 6px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 8px; border: 1px solid #eee; transition: background-color 0.2s ease, box-shadow 0.2s ease;}
    .segment-item.hovered-in-list { background-color: #e9f5ff; box-shadow: 0 0 5px rgba(0,123,255,0.3); }
    .segment-item.editing-in-list { background-color: #fffbe0; border-left: 3px solid orange; }
    .segment-item-main { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap:10px;}
    .segment-info { font-size: 0.95em; color: #333; flex-grow:1; cursor:default; }
    .segment-inputs { display:flex; gap:5px; align-items:center; }
    .segment-inputs label { font-size:0.9em; margin-bottom:0; margin-right:2px; }
    .segment-inputs input[type="number"] { width: 85px; padding:6px 8px; font-size:0.85em; margin-bottom:0;}
    .segment-actions button, .segment-actions a { padding: 8px 10px; font-size: 0.85em; width: auto; margin-left: 5px; margin-bottom: 0; white-space: nowrap; }
    .segment-actions .btn-preview { background-color: #6c757d; } .segment-actions .btn-preview:hover { background-color: #5a6268; }
    .segment-actions .btn-edit { background-color: #ffc107; color:#333; } .segment-actions .btn-edit:hover { background-color: #e0a800; }
    .segment-actions .btn-generate { background-color: #28a745; } .segment-actions .btn-generate:hover { background-color: #218838; }
    .segment-actions .btn-danger { background-color: #dc3545; } .segment-actions .btn-danger:hover { background-color: #c82333; }
    .segment-item a.download-link { display: inline-block; background-color: #17a2b8; padding: 8px 10px; font-size: 0.85em; color: white; text-decoration: none; border-radius: 5px; text-align: center; }

    /* Status & Progress */
    #statusArea { margin-top: 20px; padding: 15px; background-color: #e9ecef; border-radius: 6px; font-size: 0.95em; word-wrap: break-word; min-height:20px; line-height:1.5; }
    #progressBarContainer { width: 100%; background-color: #e0e0e0; border-radius: 6px; overflow: hidden; display: none; margin-top:10px; }
    #progressBar { width: 0%; height: 28px; background-color: #007bff; text-align: center; line-height: 28px; color: white; transition: width 0.1s ease, background-color 0.2s ease; font-weight: bold; font-size:0.9em; }

    /* Project Management */
    .project-management { margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee; display: flex; gap: 10px; }
    .project-management button { flex: 1; background-color: #6c757d; }
    .project-management button:hover:not(:disabled) { background-color: #5a6268; }
    .button-like-label { padding: 12px; background-color: #6c757d; color:white; border-radius:6px; text-align:center; cursor:pointer; transition: background-color 0.2s ease; font-weight:bold; margin-bottom:0 !important;}
    .button-like-label:hover { background-color: #5a6268; }

    /* Shortcut Help */
    .shortcut-help { font-size: 0.8em; color: #555; margin-top: 5px; text-align: center; }


    /* File Drop Area */
    .file-drop-area { border: 2px dashed #007bff; border-radius: 6px; padding: 30px; text-align: center; margin-bottom: 20px; background-color: #f8f9fa; color: #007bff; cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; }
    .file-drop-area.dragover { background-color: #e9f5ff; border-color: #0056b3; }
    .checkbox-label { display: flex; align-items: center; margin-bottom: 15px; font-weight:normal; }
    .checkbox-label input[type="checkbox"] { width: auto; margin-right: 10px; margin-bottom: 0; }
</style>
</head>
<body>

<div class="container">
    <h1>多機能動画分割ツール v2.2</h1>

    <div id="fileDropArea" class="file-drop-area">
        ここに動画/音声ファイルをドラッグ＆ドロップ、またはクリックして選択
    </div>
    <input type="file" id="videoFileInput" accept="video/*,audio/*" style="display: none;">

    <div id="sourceVideoContainer">
        <video id="sourceVideo" playsinline muted></video>
        <div id="customControls" style="display:none;">
             <button id="playPauseBtn" title="再生/一時停止 (Space)">再生</button>
             <input type="range" id="seekBar" value="0" style="flex-grow:1; margin:0 10px; display:none;" title="シークバー">
             <span id="currentTimeDisplay">0:00.000</span> /
             <span id="durationDisplay">0:00.000</span>
        </div>
        <div id="timelineContainer" style="display:none;">
            <div id="timelineProgress"></div>
            <div id="timelineTooltip"></div>
        </div>
    </div>


    <div class="tabs">
        <button class="tab-button active" data-tab="sequentialModeTab" title="逐次分割モード">逐次分割</button>
        <button class="tab-button" data-tab="freeModeTab" title="自由区間指定モード">自由区間指定</button>
        <button class="tab-button" data-tab="fixedLengthModeTab" title="固定長分割モード">固定長分割</button>
    </div>

    <div id="sequentialModeTab" class="tab-content active mode-section">
        <h3>逐次分割モード</h3>
        <p>動画を再生し、区切りたい位置で下のボタンを押すか <kbd>M</kbd> キーを押してください。</p>
        <button id="markSequentialSplitPointButton" disabled title="現在の位置で分割点をマーク (M)">現在の位置で分割点をマーク</button>
    </div>

    <div id="freeModeTab" class="tab-content mode-section">
        <h3>自由区間指定モード</h3>
        <p>下のボタンで新規区間を追加するか <kbd>N</kbd> キーを押し、開始/終了時間を編集してください。</p>
        <button id="addFreeSegmentButton" disabled title="新規区間を追加 (N)">新規区間を追加</button>
    </div>

    <div id="fixedLengthModeTab" class="tab-content mode-section">
        <h3>固定長分割モード</h3>
        <div class="input-group">
            <label for="fixedSegmentLengthInput">セグメント長 (秒):</label>
            <input type="number" id="fixedSegmentLengthInput" value="30" min="0.1" step="0.1">
        </div>
        <div class="input-group">
            <label for="fixedStartOffsetInput">開始オフセット (秒):</label>
            <input type="number" id="fixedStartOffsetInput" value="0" min="0" step="0.1">
        </div>
        <button id="previewFixedLengthSegmentsButton" disabled>固定長セグメントをマーク</button>
    </div>


    <div class="options-section">
        <h3>共通設定</h3>
        <div class="input-group">
            <label for="fileNamePrefixInput">ファイル名プレフィックス:</label>
            <input type="text" id="fileNamePrefixInput" value="segment">
        </div>
        <label class="checkbox-label">
            <input type="checkbox" id="audioOnlyModeCheckbox" title="音声のみ抽出 (O)"> 音声のみを抽出・分割する
        </label>
    </div>

    <div id="segmentsListContainer">
        <h3>マーク済みセグメントリスト</h3>
        <div id="markedSegmentsListDiv">
            </div>
    </div>

    <button id="generateAllMarkedButton" style="display: none; background-color: #28a745; margin-top:10px;" title="マーク済の未生成セグメントを全て生成">マーク済全セグメントを生成</button>
    <button id="downloadAllGeneratedButton" style="display: none; background-color: #17a2b8;" title="生成済の全セグメントをZIPでダウンロード">生成済全セグメントをZIPでダウンロード</button>
    <button id="cancelCurrentOperationButton" style="display: none; background-color: #dc3545;" title="現在の生成/圧縮処理をキャンセル (Esc)">現在の操作をキャンセル</button>

    <div id="statusArea">ステータス: 動画ファイルを選択してください。</div>
    <div id="progressBarContainer">
        <div id="progressBar">0%</div>
    </div>

    <div class="project-management">
        <button id="exportSegmentsButton" disabled title="現在の区間情報をファイルに保存 (Cmd/Ctrl + S)">区間情報をエクスポート</button>
        <label for="importSegmentsInput" class="button-like-label" style="flex:1;" title="区間情報ファイルを読み込む (Cmd/Ctrl + O)">
            区間情報をインポート
        </label>
        <input type="file" id="importSegmentsInput" accept=".json" style="display:none;">
    </div>
    <p class="shortcut-help">ショートカット: Space (再生/一時停止), M (逐次マーク), N (新規区間), Esc (キャンセル)</p>
</div>

<script>
    // --- DOM Element References (Enhanced) ---
    // ... (Most DOM references are the same as previous v2.1) ...
    const videoFileInput = document.getElementById('videoFileInput');
    const sourceVideo = document.getElementById('sourceVideo');
    const sourceVideoContainer = document.getElementById('sourceVideoContainer');
    const customControls = document.getElementById('customControls');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const seekBar = document.getElementById('seekBar');
    const currentTimeDisplay = document.getElementById('currentTimeDisplay');
    const durationDisplay = document.getElementById('durationDisplay');

    const timelineContainer = document.getElementById('timelineContainer');
    const timelineProgress = document.getElementById('timelineProgress');
    const timelineTooltip = document.getElementById('timelineTooltip');

    const tabs = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');
    let currentSplitMode = 'sequentialModeTab'; // Default mode (use full tabId)

    const markSequentialSplitPointButton = document.getElementById('markSequentialSplitPointButton');
    const addFreeSegmentButton = document.getElementById('addFreeSegmentButton');
    const fixedSegmentLengthInput = document.getElementById('fixedSegmentLengthInput');
    const fixedStartOffsetInput = document.getElementById('fixedStartOffsetInput');
    const previewFixedLengthSegmentsButton = document.getElementById('previewFixedLengthSegmentsButton');

    const fileNamePrefixInput = document.getElementById('fileNamePrefixInput');
    const audioOnlyModeCheckbox = document.getElementById('audioOnlyModeCheckbox');
    const markedSegmentsListDiv = document.getElementById('markedSegmentsListDiv');

    const generateAllMarkedButton = document.getElementById('generateAllMarkedButton');
    const downloadAllGeneratedButton = document.getElementById('downloadAllGeneratedButton');
    const cancelCurrentOperationButton = document.getElementById('cancelCurrentOperationButton');

    const statusArea = document.getElementById('statusArea');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const progressBar = document.getElementById('progressBar');
    const fileDropArea = document.getElementById('fileDropArea');

    const exportSegmentsButton = document.getElementById('exportSegmentsButton');
    const importSegmentsInput = document.getElementById('importSegmentsInput');


    // --- Global State ---
    // ... (Most global state vars are the same) ...
    let videoFile = null;
    let originalMimeType = '';
    let videoDuration = 0;
    let markedSegments = [];
    let generatedBlobsForZip = [];
    let allObjectUrls = [];
    let operationCancelled = false;
    let currentGeneratingSegmentId = null;
    let editingSegmentId = null;
    let zipWorker = null;
    let isSeekBarDragging = false;
    let previewStopTimeout = null; // For stopping segment preview


    // --- Feature Detection & Settings (Mostly unchanged) ---
    const isCaptureStreamSupported = !!(HTMLMediaElement.prototype.captureStream || HTMLMediaElement.prototype.mozCaptureStream);
    const isMediaRecorderSupported = typeof MediaRecorder !== 'undefined';
    const areWebWorkersSupported = typeof(Worker) !== "undefined";

    if (!isCaptureStreamSupported || !isMediaRecorderSupported) { /* ... */ }
    if (!areWebWorkersSupported) console.warn("Web Workers are not supported. ZIP compression might block the UI.");

    function saveAppSettings() { /* ... (unchanged) ... */
        localStorage.setItem('videoSplitterV2_fileNamePrefix', fileNamePrefixInput.value);
        localStorage.setItem('videoSplitterV2_audioOnlyMode', audioOnlyModeCheckbox.checked);
        localStorage.setItem('videoSplitterV2_currentSplitMode', currentSplitMode);
        localStorage.setItem('videoSplitterV2_fixedSegmentLength', fixedSegmentLengthInput.value);
        localStorage.setItem('videoSplitterV2_fixedStartOffset', fixedStartOffsetInput.value);
    }
    function loadAppSettings() { /* ... (unchanged) ... */
        fileNamePrefixInput.value = localStorage.getItem('videoSplitterV2_fileNamePrefix') || 'segment';
        audioOnlyModeCheckbox.checked = localStorage.getItem('videoSplitterV2_audioOnlyMode') === 'true';
        fixedSegmentLengthInput.value = localStorage.getItem('videoSplitterV2_fixedSegmentLength') || '30';
        fixedStartOffsetInput.value = localStorage.getItem('videoSplitterV2_fixedStartOffset') || '0';
        const savedMode = localStorage.getItem('videoSplitterV2_currentSplitMode');
        if (savedMode) setActiveTab(savedMode, false);
        else setActiveTab('sequentialModeTab', false); // Default if nothing saved

        fileNamePrefixInput.addEventListener('change', saveAppSettings);
        audioOnlyModeCheckbox.addEventListener('change', saveAppSettings);
        fixedSegmentLengthInput.addEventListener('change', saveAppSettings);
        fixedStartOffsetInput.addEventListener('change', saveAppSettings);
    }
    window.addEventListener('load', loadAppSettings);

    // --- File Handling & Video Player Setup (Mostly unchanged) ---
    fileDropArea.addEventListener('click', () => videoFileInput.click());
    fileDropArea.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); fileDropArea.classList.add('dragover'); });
    fileDropArea.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); fileDropArea.classList.remove('dragover'); });
    fileDropArea.addEventListener('drop', (e) => { e.preventDefault(); e.stopPropagation(); fileDropArea.classList.remove('dragover'); const files = e.dataTransfer.files; if (files.length > 0) { videoFileInput.files = files; handleFileSelect(files[0]); } });
    videoFileInput.addEventListener('change', (e) => { if (e.target.files.length > 0) handleFileSelect(e.target.files[0]); });
    function handleFileSelect(file) { /* ... (unchanged) ... */
        videoFile = file;
        cleanupBeforeNewFile();
        if (videoFile) {
            originalMimeType = videoFile.type;
            fileDropArea.textContent = `選択中のファイル: ${videoFile.name}`;
            const mediaURL = URL.createObjectURL(videoFile); allObjectUrls.push(mediaURL);
            sourceVideo.src = mediaURL; sourceVideo.style.display = 'block';
            customControls.style.display = 'flex'; timelineContainer.style.display = 'block'; seekBar.style.display = 'block';
            sourceVideo.onloadedmetadata = () => {
                videoDuration = sourceVideo.duration; durationDisplay.textContent = formatTime(videoDuration); seekBar.max = videoDuration;
                updateUIForFileLoaded();
                statusArea.textContent = `動画読み込み完了: ${videoFile.name} (${formatTime(videoDuration)})。分割モードを選択し、操作を開始してください。`;
                statusArea.style.color = '#333'; renderTimelineMarkers();
            };
            sourceVideo.onerror = () => { statusArea.textContent = 'エラー: 動画ファイルの読み込みに失敗。'; statusArea.style.color = 'red'; disableCoreFunctionality(); sourceVideo.style.display = 'none'; customControls.style.display = 'none'; timelineContainer.style.display = 'none'; seekBar.style.display = 'none'; fileDropArea.textContent = 'ここに動画/音声ファイルをドラッグ＆ドロップ、またはクリックして選択'; };
            sourceVideo.ontimeupdate = () => { currentTimeDisplay.textContent = formatTime(sourceVideo.currentTime); if (!isSeekBarDragging) seekBar.value = sourceVideo.currentTime; updateTimelineProgress(); };
            sourceVideo.onplay = () => playPauseBtn.textContent = '一時停止';
            sourceVideo.onpause = () => playPauseBtn.textContent = '再生';
            sourceVideo.onended = () => { playPauseBtn.textContent = '再生'; sourceVideo.currentTime = 0; seekBar.value = 0; };
        } else { disableCoreFunctionality(); sourceVideo.style.display = 'none'; customControls.style.display = 'none'; timelineContainer.style.display = 'none'; seekBar.style.display = 'none'; statusArea.textContent = 'ステータス: 動画ファイルを選択してください。'; fileDropArea.textContent = 'ここに動画/音声ファイルをドラッグ＆ドロップ、またはクリックして選択'; }
    }
    function cleanupBeforeNewFile() { /* ... (unchanged) ... */
        allObjectUrls.forEach(url => URL.revokeObjectURL(url)); allObjectUrls = [];
        if (sourceVideo.src && sourceVideo.src.startsWith('blob:')) sourceVideo.removeAttribute('src');
        markedSegments = []; generatedBlobsForZip = []; videoDuration = 0; editingSegmentId = null;
        renderMarkedSegmentsList(); updateTimelineProgress(); renderTimelineMarkers();
    }
    function updateUIForFileLoaded() { /* ... (unchanged) ... */ markSequentialSplitPointButton.disabled = false; addFreeSegmentButton.disabled = false; previewFixedLengthSegmentsButton.disabled = false; exportSegmentsButton.disabled = false; }
    function disableCoreFunctionality() { /* ... (unchanged) ... */ markSequentialSplitPointButton.disabled = true; addFreeSegmentButton.disabled = true; previewFixedLengthSegmentsButton.disabled = true; exportSegmentsButton.disabled = true; generateAllMarkedButton.style.display = 'none'; downloadAllGeneratedButton.style.display = 'none'; }

    // --- Custom Video Controls & Timeline (Mostly unchanged from v2.1) ---
    playPauseBtn.addEventListener('click', () => { if (sourceVideo.paused || sourceVideo.ended) sourceVideo.play(); else sourceVideo.pause(); });
    seekBar.addEventListener('input', () => { isSeekBarDragging = true; currentTimeDisplay.textContent = formatTime(seekBar.value); updateTimelineProgress(parseFloat(seekBar.value)); });
    seekBar.addEventListener('change', () => { isSeekBarDragging = false; sourceVideo.currentTime = seekBar.value; });
    timelineContainer.addEventListener('click', (e) => { if (!videoDuration || e.target.classList.contains('timeline-marker')) return; const rect = timelineContainer.getBoundingClientRect(); const clickX = e.clientX - rect.left; const percentage = clickX / rect.width; sourceVideo.currentTime = videoDuration * percentage; });
    timelineContainer.addEventListener('mousemove', (e) => { /* ... (unchanged from v2.1) ... */
        if (!videoDuration) return; const rect = timelineContainer.getBoundingClientRect(); const hoverX = e.clientX - rect.left; const percentage = hoverX / rect.width; const hoverTime = videoDuration * percentage;
        timelineTooltip.style.display = 'block'; timelineTooltip.style.left = `${Math.min(rect.width - timelineTooltip.offsetWidth - 5, Math.max(0, hoverX - timelineTooltip.offsetWidth / 2))}px`; // Keep tooltip within bounds
        timelineTooltip.textContent = formatTime(hoverTime);
        const segmentRanges = timelineContainer.querySelectorAll('.segment-range-on-timeline'); let foundSegment = false;
        segmentRanges.forEach(rangeEl => { const segment = markedSegments.find(s => s.id === parseInt(rangeEl.dataset.segmentId)); if (segment) { const startX = (segment.startTime / videoDuration) * rect.width; const endX = (segment.endTime / videoDuration) * rect.width; if (hoverX >= startX && hoverX <= endX) { timelineTooltip.textContent = `区間 ${markedSegments.indexOf(segment) + 1}: ${formatTime(segment.startTime)} - ${formatTime(segment.endTime)}`; rangeEl.classList.add('hovered'); foundSegment = true; } else { rangeEl.classList.remove('hovered'); } } });
        if (!foundSegment && timelineTooltip.textContent.includes("区間")) timelineTooltip.textContent = formatTime(hoverTime);
    });
    timelineContainer.addEventListener('mouseleave', () => { /* ... (unchanged from v2.1) ... */ timelineTooltip.style.display = 'none'; timelineContainer.querySelectorAll('.segment-range-on-timeline.hovered').forEach(el => el.classList.remove('hovered')); });
    function formatTime(timeInSeconds) { /* ... (unchanged from v2.1, already shows milliseconds) ... */
        const minutes = Math.floor(timeInSeconds / 60); const seconds = Math.floor(timeInSeconds % 60); const milliseconds = Math.floor((timeInSeconds * 1000) % 1000);
        return `${minutes}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
    }
    function updateTimelineProgress(currentTime = sourceVideo.currentTime) { /* ... (unchanged from v2.1) ... */ if (!videoDuration) { timelineProgress.style.width = '0%'; return; } const percentage = (currentTime / videoDuration) * 100; timelineProgress.style.width = `${percentage}%`; }
    function renderTimelineMarkers() { /* ... (unchanged from v2.1) ... */
        const existingElements = timelineContainer.querySelectorAll('.timeline-marker, .segment-range-on-timeline'); existingElements.forEach(el => el.remove()); if (!videoDuration) return;
        markedSegments.forEach(segment => { const isEditingThis = segment.id === editingSegmentId; const startMarker = document.createElement('div'); startMarker.className = 'timeline-marker'; startMarker.style.left = `${(segment.startTime / videoDuration) * 100}%`; startMarker.title = `区間開始: ${formatTime(segment.startTime)}`; if (isEditingThis) startMarker.classList.add('editing-start'); else if (segment.status === 'generated') startMarker.style.backgroundColor = '#28a745'; else if (segment.status === 'failed') startMarker.style.backgroundColor = '#dc3545'; timelineContainer.appendChild(startMarker);
        const endMarker = document.createElement('div'); endMarker.className = 'timeline-marker'; endMarker.style.left = `${(segment.endTime / videoDuration) * 100}%`; endMarker.title = `区間終了: ${formatTime(segment.endTime)}`; if (isEditingThis) endMarker.classList.add('editing-end'); else if (segment.status === 'generated') endMarker.style.backgroundColor = '#28a745'; else if (segment.status === 'failed') endMarker.style.backgroundColor = '#dc3545'; timelineContainer.appendChild(endMarker);
        const rangeDiv = document.createElement('div'); rangeDiv.className = 'segment-range-on-timeline'; rangeDiv.dataset.segmentId = segment.id; rangeDiv.style.left = `${(segment.startTime / videoDuration) * 100}%`; rangeDiv.style.width = `${Math.max(0, (segment.endTime - segment.startTime) / videoDuration) * 100}%`; if (isEditingThis) rangeDiv.classList.add('editing'); else if (segment.status === 'generating') rangeDiv.style.backgroundColor = 'rgba(255, 193, 7, 0.4)'; else if (segment.status === 'generated') rangeDiv.style.backgroundColor = 'rgba(40, 167, 69, 0.3)'; else if (segment.status === 'failed') rangeDiv.style.backgroundColor = 'rgba(220, 53, 69, 0.3)'; timelineContainer.appendChild(rangeDiv); });
    }

    // --- Tab/Mode Switching Logic (Mostly unchanged from v2.1) ---
    tabs.forEach(tab => { tab.addEventListener('click', () => { setActiveTab(tab.dataset.tab); if (editingSegmentId) { toggleSegmentEdit(editingSegmentId, false); editingSegmentId = null; } }); });
    function setActiveTab(tabId, doSaveSettings = true) { /* ... (unchanged from v2.1) ... */ tabs.forEach(t => t.classList.remove('active')); tabContents.forEach(tc => tc.classList.remove('active')); const activeTabButton = document.querySelector(`.tab-button[data-tab="${tabId}"]`); const activeTabContent = document.getElementById(tabId); if (activeTabButton) activeTabButton.classList.add('active'); if (activeTabContent) activeTabContent.classList.add('active'); currentSplitMode = tabId; if(doSaveSettings) saveAppSettings(); }

    // --- Segment Management Core (Mostly unchanged from v2.1) ---
    function addOrUpdateSegment(segmentData, isNew = true) { /* ... (unchanged from v2.1) ... */
        let { id, startTime, endTime } = segmentData; startTime = parseFloat(startTime); endTime = parseFloat(endTime); let validationError = null;
        if (isNaN(startTime) || isNaN(endTime)) validationError = "開始/終了時間が無効な数値です。";
        else if (endTime <= startTime) validationError = `終了時間 (${formatTime(endTime)}) は開始時間 (${formatTime(startTime)}) より後にしてください。`;
        else if (startTime < 0) validationError = "開始時間は0秒以上にしてください。";
        else if (endTime > videoDuration + 0.01) validationError = `終了時間が動画の総長 (${formatTime(videoDuration)}) を超えています。`;
        if (validationError) { statusArea.textContent = `エラー: ${validationError}`; statusArea.style.color = 'orange'; if (id && currentSplitMode === 'freeModeTab') { const itemDiv = markedSegmentsListDiv.querySelector(`.segment-item[data-segment-id="${id}"]`); if (itemDiv) { const startInputEl = itemDiv.querySelector('input[data-time-type="start"]'); const endInputEl = itemDiv.querySelector('input[data-time-type="end"]'); if (endTime <= startTime || startTime < 0) startInputEl?.classList.add('invalid-input'); else startInputEl?.classList.remove('invalid-input'); if (endTime <= startTime || endTime > videoDuration + 0.01) endInputEl?.classList.add('invalid-input'); else endInputEl?.classList.remove('invalid-input'); } } return false; }
        if (isNew) { const newSegment = { id: Date.now(), startTime, endTime, status: 'marked', isEditing: false, blob: null, fileName: '', blobUrl: null }; markedSegments.push(newSegment); id = newSegment.id; }
        else { const index = markedSegments.findIndex(s => s.id === id); if (index > -1) { if (markedSegments[index].startTime !== startTime || markedSegments[index].endTime !== endTime) { if (markedSegments[index].blobUrl) URL.revokeObjectURL(markedSegments[index].blobUrl); allObjectUrls = allObjectUrls.filter(url => url !== markedSegments[index].blobUrl); generatedBlobsForZip = generatedBlobsForZip.filter(gb => gb.name !== markedSegments[index].fileName); markedSegments[index].blob = null; markedSegments[index].blobUrl = null; markedSegments[index].fileName = ''; markedSegments[index].status = 'marked'; } markedSegments[index] = { ...markedSegments[index], startTime, endTime, isEditing: false }; if (id === editingSegmentId) editingSegmentId = null; } else { return false; } }
        markedSegments.sort((a, b) => a.startTime - b.startTime); renderMarkedSegmentsList(); renderTimelineMarkers(); updateGlobalActionButtons(); statusArea.textContent = `セグメント (${formatTime(startTime)} - ${formatTime(endTime)}) を${isNew ? '追加' : '更新'}しました。`; statusArea.style.color = '#333'; return true;
    }
    function removeSegmentById(segmentId) { /* ... (unchanged from v2.1) ... */
        const segmentIndex = markedSegments.findIndex(s => s.id === segmentId); if (segmentIndex === -1) return; const segmentToRemove = markedSegments[segmentIndex];
        if (segmentToRemove.blobUrl) URL.revokeObjectURL(segmentToRemove.blobUrl); allObjectUrls = allObjectUrls.filter(url => url !== segmentToRemove.blobUrl); generatedBlobsForZip = generatedBlobsForZip.filter(gb => gb.name !== segmentToRemove.fileName); if (editingSegmentId === segmentId) editingSegmentId = null;
        markedSegments.splice(segmentIndex, 1);
        if (currentSplitMode === 'sequentialModeTab' && markedSegments.length > 0 && segmentIndex < markedSegments.length) { for (let i = segmentIndex; i < markedSegments.length; i++) { markedSegments[i].startTime = (i > 0) ? markedSegments[i-1].endTime : 0; } }
        renderMarkedSegmentsList(); renderTimelineMarkers(); updateGlobalActionButtons(); statusArea.textContent = "セグメントを削除しました。"; if (markedSegments.length === 0) statusArea.textContent = "全てのセグメントが削除されました。";
    }

    // --- Auto-scroll and Enhanced Preview ---
    function previewSegment(segmentId) {
        const segment = markedSegments.find(s => s.id === segmentId);
        if (segment && sourceVideo.readyState >= 1) {
            // NEW: Auto-scroll to video player
            sourceVideoContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

            sourceVideo.currentTime = segment.startTime;
            sourceVideo.play();
            statusArea.textContent = `区間プレビュー中: ${formatTime(segment.startTime)} - ${formatTime(segment.endTime)}`;

            if (previewStopTimeout) clearTimeout(previewStopTimeout); // Clear previous timeout
            previewStopTimeout = setTimeout(() => {
                if (sourceVideo.currentTime >= segment.endTime || sourceVideo.paused && sourceVideo.currentTime < segment.endTime) { // Check if still in preview range and paused by this logic
                    sourceVideo.pause();
                    // Optionally reset to start of segment: sourceVideo.currentTime = segment.startTime;
                }
            }, (segment.endTime - segment.startTime + 0.1) * 1000); // Stop a bit after segment ends
        }
    }


    // --- Mode-Specific Button Handlers (Enhanced Fixed Length) ---
    markSequentialSplitPointButton.addEventListener('click', () => { /* ... (unchanged from v2.1) ... */
        if (!videoFile || videoDuration <= 0) return; const currentTime = sourceVideo.currentTime; let newStartTime = 0;
        if (markedSegments.length > 0) { const lastSegment = markedSegments.reduce((latest, s) => (s.endTime > (latest?.endTime || 0) ? s : latest), null); if (lastSegment) newStartTime = lastSegment.endTime; }
        if (currentTime <= newStartTime + 0.001) { statusArea.textContent = `新しい分割点は前の分割点の終了 (${formatTime(newStartTime)}) より後にしてください。`; statusArea.style.color = 'orange'; return; }
        addOrUpdateSegment({ startTime: newStartTime, endTime: currentTime });
    });
    addFreeSegmentButton.addEventListener('click', () => { /* ... (unchanged from v2.1) ... */
        if (!videoFile || videoDuration <= 0) return; const defaultStartTime = sourceVideo.currentTime; const defaultEndTime = Math.min(defaultStartTime + 10, videoDuration); const tempId = Date.now();
        if (addOrUpdateSegment({ id: tempId, startTime: defaultStartTime, endTime: defaultEndTime }, true)) { const addedSegment = markedSegments.find(s => s.startTime === defaultStartTime && s.endTime === defaultEndTime && s.status === 'marked'); if (addedSegment) toggleSegmentEdit(addedSegment.id, true); }
    });
    previewFixedLengthSegmentsButton.addEventListener('click', () => { /* ... (Enhanced with Offset from v2.1) ... */
        if (!videoFile || videoDuration <= 0) return; const length = parseFloat(fixedSegmentLengthInput.value); const offset = parseFloat(fixedStartOffsetInput.value);
        if (isNaN(length) || length <= 0) { statusArea.textContent = "固定長セグメントの長さは正の数値で指定してください。"; statusArea.style.color = 'orange'; return; }
        if (isNaN(offset) || offset < 0) { statusArea.textContent = "開始オフセットは0以上の数値で指定してください。"; statusArea.style.color = 'orange'; return; }
        if (offset >= videoDuration) { statusArea.textContent = "開始オフセットが動画の長さを超えています。"; statusArea.style.color = 'orange'; return; }
        let currentStartTime = offset; let count = 0;
        while (currentStartTime < videoDuration) { let endTime = Math.min(currentStartTime + length, videoDuration); if (endTime - currentStartTime < 0.01 && currentStartTime > offset) break; addOrUpdateSegment({ startTime: currentStartTime, endTime: endTime, isFixedPreview: true }); currentStartTime = endTime; count++; if (currentStartTime >= videoDuration) break; }
        statusArea.textContent = `${count}個の固定長セグメント (長さ:${length}s, オフセット:${offset}s) をマークしました。`;
    });


    // --- Rendering Segment List UI (Mostly unchanged from v2.1 - validation styling handled in addOrUpdateSegment) ---
    function renderMarkedSegmentsList() { /* ... (Mostly unchanged from v2.1, relies on helper functions for input creation and validation styling is handled elsewhere) ... */
        markedSegmentsListDiv.innerHTML = ''; let hasGeneratedFiles = generatedBlobsForZip.some(item => item.blob && item.blob.size > 0); let hasMarkedUnGenerated = false;
        if (markedSegments.length === 0) { const p = document.createElement('p'); p.textContent = 'マークされたセグメントはありません。'; p.style.textAlign = 'center'; p.style.color = '#777'; markedSegmentsListDiv.appendChild(p); updateGlobalActionButtons(); return; }
        markedSegments.forEach((segment, index) => {
            if (segment.status === 'marked' || segment.status === 'editing' || segment.status === 'failed' || segment.status === 'cancelled') hasMarkedUnGenerated = true;
            const itemDiv = document.createElement('div'); itemDiv.className = 'segment-item'; itemDiv.dataset.segmentId = segment.id; if (segment.id === editingSegmentId) itemDiv.classList.add('editing-in-list');
            itemDiv.addEventListener('mouseenter', () => { const rangeEl = timelineContainer.querySelector(`.segment-range-on-timeline[data-segment-id="${segment.id}"]`); rangeEl?.classList.add('hovered'); itemDiv.classList.add('hovered-in-list'); });
            itemDiv.addEventListener('mouseleave', () => { const rangeEl = timelineContainer.querySelector(`.segment-range-on-timeline[data-segment-id="${segment.id}"]`); rangeEl?.classList.remove('hovered'); itemDiv.classList.remove('hovered-in-list'); });
            const mainInfoDiv = document.createElement('div'); mainInfoDiv.className = 'segment-item-main';
            const infoSpan = document.createElement('span'); infoSpan.className = 'segment-info';
            const segmentInputsDiv = document.createElement('div'); segmentInputsDiv.className = 'segment-inputs'; segmentInputsDiv.style.display = (segment.id === editingSegmentId) ? 'flex' : 'none';
            const createTimeInput = (type, value) => { const lbl = document.createElement('label'); lbl.textContent = type === 'start' ? '始:' : '終:'; lbl.htmlFor = `segment-${segment.id}-${type}-time`; const input = document.createElement('input'); input.type = 'number'; input.id = lbl.htmlFor; input.value = parseFloat(value).toFixed(3); input.step = "0.001"; input.min="0"; if (videoDuration > 0) input.max = videoDuration.toFixed(3); input.dataset.timeType = type; input.addEventListener('input', () => { const tempStartTime = type === 'start' ? parseFloat(input.value) : parseFloat(startInput.value); const tempEndTime = type === 'end' ? parseFloat(input.value) : parseFloat(endInput.value); renderTimelineMarkersWithEdit(segment.id, tempStartTime, tempEndTime); validateTimeInputUI(input, tempStartTime, tempEndTime, type, startInput, endInput); }); return {lbl, input}; };
            const {lbl: startLbl, input: startInput} = createTimeInput('start', segment.startTime);
            const {lbl: endLbl, input: endInput} = createTimeInput('end', segment.endTime);
            const saveEditButton = document.createElement('button'); saveEditButton.textContent = '保存'; saveEditButton.className = 'btn-save-edit'; saveEditButton.onclick = () => addOrUpdateSegment({ ...segment, startTime: startInput.value, endTime: endInput.value }, false);
            const cancelEditBtn = document.createElement('button'); cancelEditBtn.textContent = '中止'; cancelEditBtn.className = 'btn-secondary'; cancelEditBtn.onclick = () => toggleSegmentEdit(segment.id, false);
            segmentInputsDiv.append(startLbl, startInput, endLbl, endInput, saveEditButton, cancelEditBtn);
            let statusIndicator = ''; switch (segment.status) { case 'marked': statusIndicator = `(マーク済)`; break; case 'editing': statusIndicator = `(編集中)`; break; case 'generating': statusIndicator = `(生成中...)`; break; case 'generated': statusIndicator = `(${(segment.blob?.size || 0 / 1024 / 1024).toFixed(2)} MB)`; hasGeneratedFiles = true; break; case 'failed': statusIndicator = `(生成失敗)`; break; case 'cancelled': statusIndicator = `(キャンセル済)`; break; }
            infoSpan.textContent = `区間 ${index + 1}: ${formatTime(segment.startTime)} - ${formatTime(segment.endTime)} ${statusIndicator}`; infoSpan.style.display = (segment.id === editingSegmentId) ? 'none' : 'inline';
            mainInfoDiv.appendChild(infoSpan); mainInfoDiv.appendChild(segmentInputsDiv);
            const actionsDiv = document.createElement('div'); actionsDiv.className = 'segment-actions';
            const previewBtn = document.createElement('button'); previewBtn.textContent = 'プレビュー'; previewBtn.className = 'btn-preview'; previewBtn.onclick = () => previewSegment(segment.id); actionsDiv.appendChild(previewBtn);
            if (currentSplitMode === 'freeModeTab' && (segment.status === 'marked' || segment.status === 'failed' || segment.status === 'cancelled') && segment.id !== editingSegmentId) { const editBtn = document.createElement('button'); editBtn.textContent = '時間編集'; editBtn.className = 'btn-edit'; editBtn.onclick = () => toggleSegmentEdit(segment.id, true); actionsDiv.appendChild(editBtn); }
            if ((segment.status === 'marked' || segment.status === 'failed' || segment.status === 'cancelled') && segment.id !== editingSegmentId) { const generateBtn = document.createElement('button'); generateBtn.textContent = (segment.status === 'marked') ? 'この区間を生成' : '再生成'; generateBtn.className = 'btn-generate'; generateBtn.onclick = () => generateSingleSegment(segment.id); actionsDiv.appendChild(generateBtn); }
            else if (segment.status === 'generated') { const downloadLink = document.createElement('a'); downloadLink.className = 'download-link'; downloadLink.href = segment.blobUrl; downloadLink.download = segment.fileName; downloadLink.textContent = 'ダウンロード'; actionsDiv.appendChild(downloadLink); }
            const removeBtn = document.createElement('button'); removeBtn.textContent = '削除'; removeBtn.className = 'btn-danger'; removeBtn.onclick = () => removeSegmentById(segment.id); actionsDiv.appendChild(removeBtn);
            mainInfoDiv.appendChild(actionsDiv); itemDiv.appendChild(mainInfoDiv); markedSegmentsListDiv.appendChild(itemDiv);
        });
        updateGlobalActionButtons(hasMarkedUnGenerated, hasGeneratedFiles);
    }

    function renderTimelineMarkersWithEdit(editingId, tempStartTime, tempEndTime) { /* ... (unchanged from v2.1) ... */
        renderTimelineMarkers();
        const rangeEl = timelineContainer.querySelector(`.segment-range-on-timeline[data-segment-id="${editingId}"]`);
        if (rangeEl) { rangeEl.style.left = `${(tempStartTime / videoDuration) * 100}%`; rangeEl.style.width = `${Math.max(0, (tempEndTime - tempStartTime) / videoDuration) * 100}%`; rangeEl.classList.add('editing'); }
    }
    // UI specific validation styling for inputs
    function validateTimeInputUI(inputElement, startTime, endTime, type, startInputEl, endInputEl) {
        let validationError = null;
        if (isNaN(startTime) || isNaN(endTime)) validationError = "数値エラー";
        else if (endTime <= startTime) validationError = "終了点エラー";
        else if (startTime < 0) validationError = "開始点エラー";
        else if (endTime > videoDuration + 0.01) validationError = "終了点超過エラー";

        const applyError = (el, hasError) => el?.classList.toggle('invalid-input', hasError);

        if (validationError === "数値エラー") {
            if (type === 'start' && isNaN(startTime)) applyError(startInputEl, true); else applyError(startInputEl, false);
            if (type === 'end' && isNaN(endTime)) applyError(endInputEl, true); else applyError(endInputEl, false);
        } else if (validationError === "終了点エラー") {
            applyError(startInputEl, true); applyError(endInputEl, true);
        } else if (validationError === "開始点エラー") {
            applyError(startInputEl, true); applyError(endInputEl, false); // Only start is definitely wrong
        } else if (validationError === "終了点超過エラー") {
            applyError(endInputEl, true); applyError(startInputEl, false); // Only end is definitely wrong
        } else { // No error
            applyError(startInputEl, false);
            applyError(endInputEl, false);
        }
    }
    function toggleSegmentEdit(segmentId, forceIsEditing) { /* ... (unchanged from v2.1) ... */
        if (editingSegmentId && editingSegmentId !== segmentId) { const currentlyEditingSegment = markedSegments.find(s => s.id === editingSegmentId); if (currentlyEditingSegment) currentlyEditingSegment.isEditing = false; }
        const segment = markedSegments.find(s => s.id === segmentId);
        if (segment) { segment.isEditing = (typeof forceIsEditing === 'boolean') ? forceIsEditing : !segment.isEditing; editingSegmentId = segment.isEditing ? segment.id : null; segment.status = segment.isEditing ? 'editing' : 'marked'; renderMarkedSegmentsList(); renderTimelineMarkers(); }
    }
    function updateGlobalActionButtons(hasMarked = null, hasGenerated = null) { /* ... (unchanged from v2.1) ... */
        if (hasMarked === null) hasMarked = markedSegments.some(s => s.status === 'marked' || s.status === 'editing' || s.status === 'failed' || s.status === 'cancelled');
        if (hasGenerated === null) hasGenerated = generatedBlobsForZip.some(item => item.blob && item.blob.size > 0);
        generateAllMarkedButton.style.display = hasMarked ? 'block' : 'none';
        downloadAllGeneratedButton.style.display = hasGenerated ? 'block' : 'none';
        exportSegmentsButton.disabled = markedSegments.length === 0;
    }


    // --- Project Export/Import (Enhanced Validation from v2.1 is kept) ---
    exportSegmentsButton.addEventListener('click', () => { /* ... (unchanged from v2.1) ... */ });
    importSegmentsInput.addEventListener('change', (event) => { /* ... (unchanged from v2.1) ... */ });


    // --- Segment Generation Logic (Mostly unchanged from v2.1) ---
    cancelCurrentOperationButton.addEventListener('click', () => { /* ... (unchanged from v2.1) ... */ });
    async function generateSingleSegment(segmentId) { /* ... (unchanged from v2.1) ... */ }
    function finishSegmentGeneration(segment, blob, errorMessage) { /* ... (unchanged from v2.1) ... */ }
    generateAllMarkedButton.addEventListener('click', async () => { /* ... (unchanged from v2.1) ... */ });
    function recordSegmentInternal(startTime, duration, mimeType, isAudioOnly) { /* ... (Unchanged from v2.1) ... */ }


    // --- ZIP Download (with Web Worker - unchanged from v2.1) ---
    function setupZipWorker() { /* ... (Unchanged from v2.1) ... */ }
    zipWorker = setupZipWorker();
    downloadAllGeneratedButton.addEventListener('click', async () => { /* ... (Unchanged from v2.1) ... */ });
    async function zipOnMainThread(segmentsToZip) { /* ... (Unchanged from v2.1) ... */ }
    function finishZipOperation() { /* ... (Unchanged from v2.1) ... */ }


    // --- NEW: Keyboard Shortcuts ---
    document.addEventListener('keydown', (e) => {
        // عمومی طور پر ان پٹ فیلڈز میں ٹائپ کرتے وقت شارٹ کٹس کو نظر انداز کریں
        const targetTagName = e.target.tagName.toLowerCase();
        const isEditingText = targetTagName === 'input' || targetTagName === 'textarea';
        const isSegmentTimeInputFocused = e.target.closest('.segment-inputs') && e.target.type === 'number';


        // Spacebar for Play/Pause (if not typing in a general text field)
        if (e.code === 'Space' && !isEditingText) {
            e.preventDefault();
            if (sourceVideo.src) { // Only if video is loaded
                playPauseBtn.click();
            }
        }

        // Escape to cancel current operation
        if (e.key === 'Escape') {
            if (!cancelCurrentOperationButton.disabled && cancelCurrentOperationButton.style.display !== 'none') {
                e.preventDefault();
                cancelCurrentOperationButton.click();
            } else if (editingSegmentId) { // If editing a segment, Esc cancels edit
                e.preventDefault();
                toggleSegmentEdit(editingSegmentId, false);
            }
        }

        // Shortcuts that should not work while editing segment times specifically
        if (isSegmentTimeInputFocused) {
             // Enter key within segment time inputs should save that segment
            if (e.key === 'Enter') {
                e.preventDefault();
                const segmentItem = e.target.closest('.segment-item');
                if (segmentItem) {
                    const saveButton = segmentItem.querySelector('.btn-save-edit');
                    saveButton?.click();
                }
            }
            return; // Don't process other general shortcuts if focused on segment time input
        }


        if (isEditingText && !isSegmentTimeInputFocused) return; // Ignore other shortcuts if in other input fields

        // Modifier keys (Cmd for macOS, Ctrl for others)
        const modKey = e.metaKey || e.ctrlKey;

        if (modKey && e.key.toLowerCase() === 's') { // Cmd/Ctrl + S to Export
            e.preventDefault();
            if (!exportSegmentsButton.disabled) exportSegmentsButton.click();
        }
        if (modKey && e.key.toLowerCase() === 'o') { // Cmd/Ctrl + O to trigger Import click
            e.preventDefault();
            // Find the label associated with importSegmentsInput and click it
            const importLabel = document.querySelector(`label[for="${importSegmentsInput.id}"]`);
            importLabel?.click();
             // If no label, directly click the input (though it's hidden, label click is better)
            if (!importLabel) importSegmentsInput.click();
        }


        // Mode-specific or general action shortcuts (no modifier key)
        switch (e.key.toLowerCase()) {
            case 'm': // Mark in Sequential Mode
                if (currentSplitMode === 'sequentialModeTab' && !markSequentialSplitPointButton.disabled) {
                    e.preventDefault();
                    markSequentialSplitPointButton.click();
                }
                break;
            case 'n': // New segment in Free Mode
                if (currentSplitMode === 'freeModeTab' && !addFreeSegmentButton.disabled) {
                    e.preventDefault();
                    addFreeSegmentButton.click();
                }
                break;
            case 'o': // Toggle Audio Only Mode
                 e.preventDefault();
                 audioOnlyModeCheckbox.checked = !audioOnlyModeCheckbox.checked;
                 // Manually trigger change event if needed for other logic, or save settings directly
                 saveAppSettings();
                 statusArea.textContent = `音声のみモードが${audioOnlyModeCheckbox.checked ? 'オン' : 'オフ'}になりました。`;
                break;
            // Add more shortcuts as needed, e.g., for generating selected segment, navigating tabs, etc.
        }
    });


    // --- Cleanup on Page Unload ---
    window.addEventListener('beforeunload', () => { /* ... (unchanged) ... */
        allObjectUrls.forEach(url => URL.revokeObjectURL(url));
        if (zipWorker) zipWorker.terminate();
    });

</script>
</body>
</html>